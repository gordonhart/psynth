use crate::{
    Sample,
    Consumer,
    Generator,
    Observer,
};


/// Duplicates single-stream audio to as many channels as necessary.
pub struct MonoConsumer {
    channels: usize,
    generator: Option<Generator>,
    observer_channel: Option<std::sync::mpsc::Sender<Sample>>,
    observer_thread_handle: Option<std::thread::JoinHandle<Sample>>,
}


impl MonoConsumer {
    pub fn new(channels: usize) -> Self {
        Self {
            channels: channels,
            generator: None,
            observer_channel: None,
            observer_thread_handle: None,
        }
    }

    pub fn bind(mut self, generator: Generator) -> Self {
        self.generator = Some(generator);
        self
    }

    // TODO: make part of the `Consumer` trait? add new `Observable` trait? keep here?
    pub fn bind_observers(mut self, mut observers: Vec<Box<dyn Observer + Send>>) -> Self {
        let (sender, receiver) = std::sync::mpsc::channel();
        self.observer_thread_handle = Some(std::thread::spawn(move || loop {
            let sample = receiver.recv().expect("channel closed");
            for observer in observers.iter_mut() {
                observer.sample(sample);
            }
        }));
        self.observer_channel = Some(sender);
        self
    }
}


impl Consumer for MonoConsumer {
    /// Fill the provided the output buffer as generated by the bound `Generator`.
    ///
    /// All channels of the output stream are written with the same data.
    fn fill(&mut self, output_buffer: &mut [Sample]) {
        // TODO: not crazy about the verbosity of this technique used to access self.generator
        match &mut self.generator {
            Some(ref mut gen) => {
                for frame in output_buffer.chunks_mut(self.channels) {
                    // TODO: reintroduce value type parameterization from example
                    let sample = gen();
                    for location in frame.iter_mut() {
                        *location = sample;
                    }
                    if let Some(ref sender) = &self.observer_channel {
                        sender.send(sample).expect("channel closed");
                    }
                }
            },
            None => panic!("`fill` called on unbound `Consumer`"),
        }
    }
}


/// Consumer capable of packing dual (stereo) audio streams into provided output buffers.
///
/// NOTE: if the number of channels is not exactly 2, the behavior defaults to that of the
/// `MonoConsumer` where each channel has the same data written to it. Here that data is the sum
/// of the two held streams.
pub struct StereoConsumer {
    channels: usize,
    generators: Option<(Generator, Generator)>,
}


impl StereoConsumer {
    pub fn new(channels: usize) -> Self {
        if channels != 2 {
            eprintln!("{} channels provided to `StereoConsumer::new`, should be 2 -- are you sure \
                you want a `StereoConsumer`?", channels);
        }
        Self {
            channels: channels,
            generators: None,
        }
    }

    pub fn bind(mut self, left: Generator, right: Generator) -> Self {
        self.generators = Some((left, right));
        self
    }
}


impl Consumer for StereoConsumer {
    fn fill(&mut self, output_buffer: &mut [Sample]) {
        if let Some((ref mut gen_l, ref mut gen_r)) = &mut self.generators {
            for frame in output_buffer.chunks_mut(self.channels) {
                if self.channels == 2 {
                    frame[0] = gen_l();
                    frame[1] = gen_r();
                } else {
                    let sample = gen_l() + gen_r();
                    for location in frame.iter_mut() {
                        *location = sample;
                    }
                }
            }
        } else {
            panic!("`StereoConsumer::fill` called but generators have not been bound");
        }
    }
}
